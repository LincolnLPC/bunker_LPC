# Стабильность видео с камер игроков (WebRTC)

## Проблема

После обновления страницы одним из игроков камера другого может появляться или пропадать нестабильно (чередование «появилась → пропала»). Тестирование ведётся по локальной сети; на стабильность могут влиять порядок подключения к сигналингу, тайминги и особенности P2P.

## Что уже сделано в коде

- **Не обрываем соединения в состоянии «ожидание answer»** — из периодической проверки убрано состояние `have-local-offer`, чтобы не разрывать канал, пока вторая сторона ещё не ответила (это устраняло чередование появление/пропадание).
- **Оба игрока отправляют offer** — и инициатор, и принимающий создают соединение и шлют offer; при «гонке» (glare) одна сторона принимает чужой offer, соединение устанавливается.
- **Буфер сигналов 6 секунд** — входящие offer/answer/ICE в первые 6 секунд после подключения к каналу буферизуются и обрабатываются в правильном порядке.
- **Мгновенная очистка при failed/closed** — при падении соединения пир сразу удаляется и запускается переподключение (без ожидания 12 секунд).
- **Восстановление потока из getReceivers()** — раз в 4 секунды для уже connected пиров без потока собирается поток из приёмников и кладётся в `remoteStreams`.
- **Повторные попытки play() в PlayerCard** — для видео делаются повторные вызовы `play()` с задержками 400 ms, 1 s, 2 s для медленной сети/LAN.

Эти меры повышают стабильность, но не гарантируют 100% работу при любой последовательности обновлений и в любой сети.

---

## Варианты, которые максимально или на 100% решают проблему

Ниже — варианты по возрастанию сложности деплоя и надёжности. Учтены упрощённый деплой и тестирование по локальной сети.

---

### 1. Локальная сеть: проверка окружения (минимум изменений)

**Идея:** Убедиться, что по LAN нет лишних препятствий для WebRTC.

**HTTPS для камеры/микрофона по LAN:**  
Браузер даёт доступ к камере и микрофону только в secure context (HTTPS или localhost). При заходе по `http://192.168.x.x:3000` доступ к медиа может блокироваться. В проекте включён локальный HTTPS: выполните `pnpm run generate-cert` (один раз), затем `pnpm dev`. Если в папке `.cert` есть `cert.pem` и `key.pem`, сервер поднимается по HTTPS и выводит в консоль ссылку для LAN (например `https://192.168.1.5:3000`). Откройте её на устройствах в сети; предупреждение о самоподписанном сертификате нужно принять один раз.

**Второй игрок по LAN:**  
Второй игрок открывает ссылку на комнату с того же хоста (например `https://192.168.1.5:3000/game/XXXX`). Если он не авторизован, увидит «Чтобы зайти в комнату, войдите в аккаунт» и кнопку «Войти» — после входа будет перенаправлен обратно в комнату. Важно: входить нужно на том же адресе (по LAN), чтобы сессия и куки были для этого origin.

**Что ещё сделать:**

- Оба устройства в одной подсети (один роутер/коммутатор).
- Временно отключить файрвол/антивирус на портах UDP (обычно 50000–60000) на обоих ПК.
- Использовать один и тот же браузер (Chrome/Edge) на обоих устройствах.
- Не обновлять страницу слишком часто; после обновления подождать 5–10 секунд, пока канал и список игроков обновятся.

**Плюсы:** Без изменений кода и деплоя.  
**Минусы:** Не гарантирует стабильность при любой последовательности действий; возможны гонки и «чередование».

---

### 2. TURN-сервер (упрощённый деплой)

**Идея:** Добавить TURN, чтобы при проблемах с прямым P2P (NAT, несимметричный роутинг по LAN) медиа шло через сервер.

**Варианты деплоя:**

- **Бесплатный TURN:** например [metered.ca/tools/openrelay](https://www.metered.ca/tools/openrelay/) — выдают бесплатные лимиты, в коде подставляете `urls`, `username`, `credential`.
- **Свой TURN (Coturn) на VPS или том же сервере, где крутится приложение:** один Docker-контейнер или установка пакетом; в Next.js/клиенте в конфиг RTCPeerConnection добавляете `iceServers: [ { urls: 'stun:...' }, { urls: 'turn:...', username, credential } ]`.

**Плюсы:** Один сервис, один деплой; часто решает проблемы с подключением (в т.ч. странные кейсы по LAN).  
**Минусы:** Трафик идёт через сервер; для «чистой» LAN не всегда нужен, но повышает предсказуемость.

**Где менять код:** `lib/webrtc/peer-connection.ts` — константа с `iceServers` (сейчас только STUN). Добавить TURN и при необходимости выносить учётные данные в env.

---

### 3. SFU (сервер пересылает потоки) — максимальная стабильность

**Идея:** Каждый клиент поднимает одно соединение к серверу (WebRTC или WebSocket+медиа). Сервер принимает поток и раздаёт его остальным. Нет прямой P2P-связи между игроками — меньше гонок, переподключений и зависимости от порядка обновления страницы.

**Варианты с упрощённым деплоем:**

| Решение        | Деплой                          | Плюсы                          |
|----------------|----------------------------------|--------------------------------|
| **Livekit**    | Cloud или один Docker/сервер    | Готовый SDK, комнаты, очень стабильно |
| **Jitsi Videobridge** | Docker / self-hosted       | Open Source, привычный сценарий «конференция» |
| **Mediasoup**  | Свой сервер (Node) + один процесс | Гибкость, один процесс медиа-сервера |
| **Pion** (Go)  | Один бинарник или Docker        | Простой деплой, один исполняемый файл |

**Плюсы:** Один канал до сервера на клиента, переподключение только к серверу — поведение после refresh предсказуемо и стабильно.  
**Минусы:** Нужен отдельный сервис (или облачный план), изменения в коде (замена текущего P2P на клиенте и бэкенд для токенов/комнат).

---

### 4. Отправка видео через сервер (не WebRTC P2P)

**Идея:** Камера кодируется и отправляется на ваш backend (WebSocket/HTTP), сервер раздаёт кадры/поток остальным участникам комнаты. WebRTC между игроками не используется.

**Реализация (упрощённо):**

- Клиент: `getUserMedia` → `MediaRecorder` или захват кадров с canvas → отправка по WebSocket (или chunked HTTP) на сервер.
- Сервер: хранит последний поток/кадры по `roomId`/`playerId`, при подключении нового клиента отдаёт ему потоки остальных.
- Другие клиенты: получают поток по WebSocket и отображают в `<video>` (например, через MSE или blob-URL).

**Плюсы:** Полный контроль над доставкой; после обновления страницы клиент просто заново подписывается на потоки комнаты — нет гонок offer/answer.  
**Минусы:** Нагрузка и трафик на сервере выше, нужна реализация кодирования/формата и доставки; задержка обычно выше, чем у P2P.

---

### 5. Гибрид: текущий P2P + опция «переподключить видео»

**Идея:** Оставить текущую схему, но дать пользователю кнопку «Обновить видео» / «Переподключить камеры», которая принудительно пересоздаёт все WebRTC-соединения в комнате (например, через общий сигнал «всем переподключиться» или сброс состояния пиров и повторная отправка offer).

**Плюсы:** Минимальные изменения, без нового сервера; пользователь может «починить» картинку сам.  
**Минусы:** Не устраняет корневую причину; стабильность по-прежнему не гарантирована.

---

## Рекомендация по приоритетам

1. **Сейчас:** Уже внесённые правки (без `have-local-offer` в таймере, буфер 6 с, оба шлют offer, восстановление из getReceivers, retry play) — использовать и тестировать по LAN.
2. **Если нестабильность остаётся:** Добавить TURN (вариант 2) с бесплатным или своим Coturn — простой деплой, часто снимает странные кейсы.
3. **Если нужна максимальная стабильность и не важен «упрощённый деплой»:** Ввести SFU (вариант 3), например Livekit Cloud или один инстанс Jitsi/Livekit в Docker — это даёт поведение, близкое к 100% предсказуемому после любых обновлений страницы.
4. **Если важна только LAN и контроль:** Проверить окружение (вариант 1) и при необходимости добавить кнопку принудительного переподключения видео (вариант 5).

---

## Связь с тестированием по локальной сети

- По LAN часто срабатывают только host-кандидаты ICE; задержки маленькие, но порядок событий (кто первый подписался на канал, кто первый отправил offer) может давать гонки.
- Увеличенный буфер сигналов и то, что оба игрока шлют offer, как раз смягчают эти гонки.
- Если в LAN есть несколько подсетей, VPN или строгий файрвол, TURN (вариант 2) выравнивает поведение так же, как в интернете.
- SFU (вариант 3) убирает зависимость от P2P и порядка обновления страницы и даёт стабильную картинку и по LAN, и в интернете.
