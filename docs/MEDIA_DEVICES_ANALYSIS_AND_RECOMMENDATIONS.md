# Анализ изменений камеры и микрофона и рекомендации по улучшению

## Контекст

После деплоя на Vercel возникали проблемы: камера и микрофон не работали, приложение показывало «заняты» или «таймаут». Внесённые правки устранили эти проблемы — устройства работают штатно.

---

## Изменения, повлиявшие на камеру и микрофон

### 1. Страница профиля: удаление `getUserMedia` (ключевое исправление)

**Файл:** `app/profile/edit/page.tsx`

**Было:**
- При монтировании вызывался `loadDevices()`, который вызывал `getUserMedia({ video: true, audio: true })` для получения меток устройств.
- Поток сразу останавливался (`track.stop()`), но камера и микрофон всё равно могли оставаться занятыми.

**Почему это ломало игру:**
- При открытой вкладке профиля или при переходе Профиль → Игра камера/микрофон уже могли быть заняты профилем.
- В некоторых браузерах и конфигурациях освобождение устройств после `track.stop()` происходит не сразу.
- Prefetch/предзагрузка страниц могла вызывать `getUserMedia` до входа в игру.

**Сделано:**
- Удалён вызов `getUserMedia` на странице профиля.
- Список устройств формируется только через `enumerateDevices()` без захвата медиа.
- Метки при отсутствии разрешения подменяются на «Камера 1», «Микрофон 1» и т.п.

**Влияние:** Основное исправление. Страница профиля больше не занимает камеру и микрофон, они остаются доступны для игры.

---

### 2. Хук WebRTC: повтор при ошибке без `deviceId`

**Файл:** `hooks/use-webrtc.ts`

**Было:**
- Один вызов `getUserMedia` с `deviceId` из настроек профиля.
- При `NotReadableError`, `OverconstrainedError` или таймауте показывалось сообщение «заняты» без повторной попытки.

**Почему это ломало игру:**
- `cameraDeviceId` и `microphoneDeviceId` в профиле могли устареть (смена устройства, браузера, драйверов).
- Браузер мог падать с `OverconstrainedError` или `NotReadableError` из‑за невалидного `deviceId`.
- Приложение считало устройства занятыми, хотя причина была в устаревших ID.

**Сделано:**
- Первая попытка — с `deviceId` из профиля (если есть).
- При ошибках `NotReadableError`, `OverconstrainedError`, таймауте и фразах вроде «Could not start video/audio source» — вторая попытка без `deviceId`.
- Браузер сам выбирает устройство по умолчанию.

**Влияние:** Устраняет ложные «устройство занято» и «устройство не поддерживает параметры», если ID в профиле устарели.

---

### 3. Хук WebRTC: увеличение таймаута и повтор при таймауте

**Файл:** `hooks/use-webrtc.ts`

**Было:**
- Один таймаут 15 секунд.
- При таймауте не было повторной попытки.

**Почему это ломало игру:**
- На медленных и мобильных камерах инициализация может занимать больше 15 секунд.
- Одна неуспешная попытка приводила к показу «таймаут» и «возможно занято».

**Сделано:**
- Первый таймаут увеличен до 25 секунд.
- При таймауте выполняется повторная попытка без `deviceId` с таймаутом 40 секунд.
- Повтор по таймауту делается даже если в профиле нет сохранённых устройств.

**Влияние:** Медленные камеры и микрофоны успевают инициализироваться, уменьшается число ложных таймаутов.

---

## Изменения, не связанные с камерой и микрофоном

Эти правки касались шаблонов и API и на медиа не влияют:

- `app/api/game-templates/route.ts` — обработка ошибок и fallback при отсутствии колонок в БД
- `app/lobby/create/page.tsx` — вывод деталей ошибки при сохранении шаблона

---

## Рекомендации по улучшению работы камеры и микрофона

### Краткосрочные (минимальные правки кода)

1. **Освобождение потока при уходе со страницы**
   - В `app/game/[roomCode]/page.tsx` при размонтировании (переходе с игры) вызывать `localStream?.getTracks().forEach(track => track.stop())` — это уже реализовано в `use-webrtc.ts`.
   - Добавить `visibilitychange` и при скрытии вкладки временно отключать видео (например, `track.enabled = false`), а при возврате — включать, чтобы снизить нагрузку и освободить устройства, если браузер это позволяет.

2. **Валидация `deviceId` перед использованием**
   - Перед `getUserMedia` вызывать `enumerateDevices()` и проверять, что `cameraDeviceId` / `microphoneDeviceId` есть в списке.
   - Если ID нет — сразу вызывать `getUserMedia` без `deviceId` и не тратить время на первую попытку с невалидным ID.

3. **Сброс устаревших ID в профиле**
   - При успешном fallback (повтор без `deviceId`) опционально обновлять `media_settings` в профиле, сбрасывая `cameraDeviceId` и `microphoneDeviceId`, чтобы следующие сессии не пытались использовать старые ID.

### Среднесрочные (архитектура)

4. **Один источник медиа**
   - Запрашивать `getUserMedia` только на странице игры.
   - На странице профиля не вызывать `getUserMedia` ни при монтировании, ни при «Обновить» — только `enumerateDevices()`.

5. **Permission Policy (Feature Policy)**
   - В `next.config.js` или заголовках задать:
     - `camera: self`
     - `microphone: self`
   - Явно разрешить медиа только для текущего origin и запретить для iframe с внешних доменов, чтобы избежать конфликтов.

6. **Индикация загрузки**
   - Показывать состояние «Подключение камеры…» с индикатором загрузки во время ожидания `getUserMedia`.
   - При необходимости отображать прогресс (например, «Повторная попытка…» при fallback).

### Долгосрочные (надёжность и качество)

7. **TURN‑сервер**
   - Добавить TURN в `iceServers` для WebRTC.
   - Снижает проблемы при строгих NAT и улучшает соединение между игроками.

8. **Упрощение constraints**
   - При повторных ошибках пробовать более мягкие ограничения:
     - `{ video: true, audio: true }` без `width`, `height`, `facingMode`.
   - Уменьшает число сбоев на нестандартных или старых камерах.

9. **Логирование и аналитика**
   - Логировать в консоль или бекенд: успех/ошибку, тип ошибки, время ответа `getUserMedia`.
   - Это позволит отслеживать типичные браузеры, устройства и ошибки для дальнейшей оптимизации.

10. **Документация для пользователя**
    - Добавить в FAQ или хелп инструкции:
      - Закрывать другие вкладки/приложения, использующие камеру.
      - Давать разрешение при первом запросе браузера.
      - Обновлять страницу, если устройство не появляется.
      - Проверять настройки камеры/микрофона в настройках браузера (сайта).

---

## Чек‑лист для проверки медиа

- [ ] Камера и микрофон запрашиваются только на странице игры (не в профиле, не в лобби).
- [ ] Используется HTTPS (Vercel это обеспечивает).
- [ ] Есть fallback при ошибке с `deviceId` (повтор без ID).
- [ ] Таймауты достаточны (25 и 40 секунд).
- [ ] Потоки останавливаются при уходе со страницы.
- [ ] Есть понятное сообщение при блокировке доступа (разрешения браузера).
- [ ] Кнопка «Включить камеру» позволяет повторить попытку вручную.
- [ ] VDO.ninja поддерживается как альтернативный источник видео.

---

## Резюме

Работоспособность камеры и микрофона восстановлена в первую очередь за счёт:

1. **Отказа от `getUserMedia` на странице профиля** — устранён конфликт за устройства между профилем и игрой.
2. **Повторной попытки без `deviceId`** — обработка устаревших ID в настройках.
3. **Увеличения таймаутов и повтора при таймауте** — учёт медленных устройств.

Дальнейшие улучшения (валидация `deviceId`, Permission Policy, TURN, логирование) повысят стабильность и предсказуемость работы камеры и микрофона в разных браузерах и на разных устройствах.

---

## Пошаговая инструкция: добавление TURN‑сервера

TURN‑сервер нужен, когда прямое P2P‑соединение между игроками не устанавливается (строгий NAT, симметричный NAT, firewall). Без TURN видео/аудио могут не отображаться, даже если камера и микрофон работают локально.

### Шаг 1: Получить TURN‑учётные данные

**Вариант A — бесплатный публичный TURN (для тестов):**
- Например [metered.ca/tools/openrelay](https://www.metered.ca/tools/openrelay/) — выдают временные `urls`, `username`, `credential` для тестирования.
- Лимиты по трафику, подходят для разработки.

**Вариант B — свой TURN (Coturn) на VPS:**
- Арендовать VPS (DigitalOcean, Hetzner, и т.п.).
- Установить Coturn: `apt install coturn` (Ubuntu/Debian).
- Настроить `turnserver.conf`: `listening-port=3478`, `relay-ip`, `realm`, учётные данные.
- Открыть порты 3478 (UDP/TCP), 49152–65535 (UDP для relay).
- Получить `username` и `credential` (обычно с ограниченным временем жизни).

### Шаг 2: Добавить переменные окружения

В `.env.local` и в Vercel → Settings → Environment Variables:

```
NEXT_PUBLIC_TURN_URLS=turn:your-turn-server.com:3478
NEXT_PUBLIC_TURN_USERNAME=your_username
NEXT_PUBLIC_TURN_CREDENTIAL=your_credential
```

Используйте `NEXT_PUBLIC_` только для значений, которые допустимо показывать на клиенте. Для TURN credential лучше получать с бекенда (см. Шаг 4).

### Шаг 3: Обновить `lib/webrtc/peer-connection.ts`

Сейчас используется только STUN:

```ts
const STUN_SERVERS: RTCConfiguration = {
  iceServers: [
    { urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302"] },
  ],
}
```

Нужно добавить TURN в `iceServers`:

```ts
const iceServers: RTCIceServer[] = [
  { urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302"] },
]

if (process.env.NEXT_PUBLIC_TURN_URLS) {
  iceServers.push({
    urls: process.env.NEXT_PUBLIC_TURN_URLS.split(",").map(u => u.trim()),
    username: process.env.NEXT_PUBLIC_TURN_USERNAME || undefined,
    credential: process.env.NEXT_PUBLIC_TURN_CREDENTIAL || undefined,
  })
}

const config: RTCConfiguration = { iceServers }
// В конструкторе PeerConnectionManager:
this.peerConnection = new RTCPeerConnection(config)
```

### Шаг 4 (опционально): TURN credential с бекенда

Чтобы не светить credential в клиентском коде, создайте API `/api/webrtc/turn-config`:

- Метод: GET.
- Проверка авторизации.
- Генерация временного `username` и `credential` (например, через Coturn TURN REST API или свой генератор).
- Ответ: `{ iceServers: [{ urls, username, credential }] }`.

На клиенте перед созданием `RTCPeerConnection` вызывать этот API и подставлять `iceServers` из ответа.

### Шаг 5: Проверка

1. Задеплойте изменения на Vercel.
2. Подключите двух игроков из разных сетей (например, домашний интернет и мобильный).
3. В DevTools → Application → WebRTC (или chrome://webrtc-internals) посмотрите, используется ли TURN relay.
4. При успешном TURN в логах/интерфейсе будет видно `relay` в типе кандидата.

### Шаг 6: Мониторинг и лимиты

- TURN relay потребляет трафик и CPU на сервере.
- Следите за лимитами (публичные сервисы) или нагрузкой (свой Coturn).
- При необходимости ограничьте количество TURN‑соединений и длительность сессий.
