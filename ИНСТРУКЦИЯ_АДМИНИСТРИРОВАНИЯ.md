# Инструкция по администрированию

## Как назначить пользователя админом

### Шаг 1: Найдите пользователя (ВАЖНО!)

Перед назначением админа нужно найти правильный email или UUID пользователя.

1. Откройте панель Supabase: https://supabase.com/dashboard
2. Выберите ваш проект
3. Перейдите в раздел **SQL Editor**
4. Выполните один из запросов для поиска пользователя:

**Поиск по email (точное совпадение):**
```sql
SELECT id, email, created_at, email_confirmed_at 
FROM auth.users 
WHERE email = 'user@example.com';
```

**Поиск по части email (без учета регистра):**
```sql
SELECT id, email, created_at, email_confirmed_at 
FROM auth.users 
WHERE LOWER(email) LIKE LOWER('%часть_email%');
```

**Поиск по username:**
```sql
SELECT p.id, p.username, p.display_name, u.email, u.created_at
FROM profiles p
JOIN auth.users u ON u.id = p.id
WHERE p.username = 'myusername';
```

**Список всех пользователей (первые 20):**
```sql
SELECT u.id, u.email, u.created_at, p.username, p.display_name
FROM auth.users u
LEFT JOIN profiles p ON p.id = u.id
ORDER BY u.created_at DESC
LIMIT 20;
```

### Шаг 2: Назначьте админа

После того как нашли правильный email или UUID:

1. В том же **SQL Editor** откройте файл `scripts/024-grant-admin-role.sql`
2. Выберите один из вариантов:

#### Вариант A: Назначение по email (рекомендуется)
```sql
-- Замените 'user@example.com' на реальный email пользователя
DO $$
DECLARE
  target_user_id UUID;
  target_email TEXT := 'user@example.com'; -- ВАШ EMAIL ЗДЕСЬ
  admin_role TEXT := 'admin';
  user_email TEXT;
BEGIN
  -- Поиск без учета регистра
  SELECT id, email INTO target_user_id, user_email
  FROM auth.users
  WHERE LOWER(email) = LOWER(target_email);
  
  IF target_user_id IS NULL THEN
    RAISE EXCEPTION 'User with email "%" not found. Please check the email.', target_email;
  END IF;
  
  RAISE NOTICE 'Found user: % (email: %)', target_user_id, user_email;
  
  -- Проверка и создание профиля при необходимости
  IF NOT EXISTS (SELECT 1 FROM profiles WHERE id = target_user_id) THEN
    INSERT INTO profiles (id, username, subscription_tier)
    VALUES (
      target_user_id, 
      'user_' || SUBSTRING(target_user_id::TEXT, 1, 8),
      'basic'
    )
    ON CONFLICT (id) DO NOTHING;
  END IF;
  
  INSERT INTO admin_roles (user_id, role, granted_by, granted_at)
  VALUES (target_user_id, admin_role, target_user_id, NOW())
  ON CONFLICT (user_id) 
  DO UPDATE SET role = admin_role, granted_at = NOW();
  
  RAISE NOTICE '✓ Admin role granted successfully!';
END $$;
```

**Важно:** Скрипт теперь ищет email без учета регистра (например, `User@Example.com` и `user@example.com` - одно и то же).

#### Вариант B: Назначение по username
```sql
-- Замените 'USERNAME_HERE' на реальный username пользователя
DO $$
DECLARE
  target_user_id UUID;
  target_username TEXT := 'myusername'; -- ВАШ USERNAME ЗДЕСЬ
  admin_role TEXT := 'admin';
BEGIN
  SELECT id INTO target_user_id
  FROM profiles
  WHERE username = target_username;
  
  IF target_user_id IS NULL THEN
    RAISE EXCEPTION 'User with username not found';
  END IF;
  
  INSERT INTO admin_roles (user_id, role, granted_by, granted_at)
  VALUES (target_user_id, admin_role, target_user_id, NOW())
  ON CONFLICT (user_id) 
  DO UPDATE SET role = admin_role, granted_at = NOW();
  
  RAISE NOTICE 'Admin role granted successfully';
END $$;
```

6. Нажмите **Run** для выполнения скрипта

### Способ 2: Прямой SQL запрос

Если вы знаете UUID пользователя, можете использовать простой INSERT:

```sql
INSERT INTO admin_roles (user_id, role, granted_by, granted_at)
VALUES ('USER_UUID_HERE', 'admin', 'USER_UUID_HERE', NOW())
ON CONFLICT (user_id) 
DO UPDATE SET role = 'admin', granted_at = NOW();
```

### Решение проблем

### Ошибка: "User with email not found"

Эта ошибка означает, что пользователь с указанным email не найден. Решения:

1. **Проверьте правильность email:**
   - Убедитесь, что email указан точно так, как при регистрации
   - Попробуйте поиск по части email (см. Шаг 1 выше)

2. **Проверьте, зарегистрирован ли пользователь:**
   ```sql
   -- Посмотрите всех пользователей
   SELECT id, email, created_at 
   FROM auth.users 
   ORDER BY created_at DESC 
   LIMIT 20;
   ```

3. **Используйте поиск по username вместо email:**
   ```sql
   -- Найдите пользователя по username
   SELECT p.id, p.username, p.display_name, u.email
   FROM profiles p
   JOIN auth.users u ON u.id = p.id
   WHERE p.username = 'myusername';
   ```

4. **Используйте UUID напрямую:**
   Если вы знаете UUID пользователя, используйте Вариант B из скрипта.

## Как перейти в админку

После назначения роли админа:

1. Убедитесь, что вы авторизованы в приложении
2. Перейдите по адресу: **`/admin`**
   - Если приложение запущено локально: `http://localhost:3000/admin`
   - Если приложение развернуто: `https://your-domain.com/admin`

3. Если у вас есть права админа, вы увидите админ-панель с двумя вкладками:
   - **Жалобы** - список всех жалоб пользователей
   - **Баны** - список всех забаненных пользователей

## Проверка текущих админов

Чтобы увидеть всех текущих админов и модераторов:

```sql
SELECT 
  ar.id,
  ar.user_id,
  ar.role,
  ar.granted_at,
  p.username,
  p.display_name,
  u.email
FROM admin_roles ar
JOIN profiles p ON p.id = ar.user_id
JOIN auth.users u ON u.id = ar.user_id
ORDER BY ar.granted_at DESC;
```

## Удаление прав админа

Чтобы удалить права админа у пользователя:

```sql
DELETE FROM admin_roles 
WHERE user_id = 'USER_UUID_HERE';
```

Или по email:

```sql
DELETE FROM admin_roles 
WHERE user_id = (SELECT id FROM auth.users WHERE email = 'user@example.com');
```

## Роли

В системе доступны две роли:
- **`admin`** - полный доступ к админ-панели
- **`moderator`** - модератор (в текущей реализации имеет те же права, что и admin)

## Решение проблемы "Доступ запрещен" после назначения админа

### Ошибка: "infinite recursion detected in policy"

Если вы видите ошибку **"infinite recursion detected in policy for relation admin_roles"**, это означает, что RLS политика создает циклическую зависимость.

**Решение:** Выполните скрипт `scripts/029-fix-admin-rls-no-recursion.sql`:

```sql
-- Исправление RLS политики - убираем рекурсию
DROP POLICY IF EXISTS "Admins can view admin roles" ON admin_roles;
DROP POLICY IF EXISTS "Users can view own admin role, admins can view all" ON admin_roles;

-- Простая политика: пользователь может видеть только свою запись
-- Это предотвращает рекурсию, так как не запрашивает admin_roles снова
CREATE POLICY "Users can view own admin role" ON admin_roles
  FOR SELECT
  USING (user_id = auth.uid());
```

**Важно:** Эта политика позволяет пользователю видеть только свою собственную запись в `admin_roles`, что достаточно для проверки статуса админа на странице админки.

**Файл:** `scripts/029-fix-admin-rls-no-recursion.sql`

## Важные замечания

1. **Пользователь должен иметь профиль** - перед назначением админа убедитесь, что пользователь зарегистрирован и имеет запись в таблице `profiles`
2. **RLS политики** - таблица `admin_roles` защищена Row Level Security, поэтому для назначения админа нужно использовать SQL Editor в Supabase (который работает с правами service role)
3. **Первый админ** - для назначения первого админа вам нужен доступ к Supabase SQL Editor с правами администратора проекта
4. **После назначения админа** - обязательно выполните скрипт `025-fix-admin-roles-rls.sql` для исправления RLS политики

## Доступ к админке

Админка проверяет наличие записи в таблице `admin_roles` для текущего пользователя. Если записи нет, доступ будет запрещен с сообщением "У вас нет доступа к админ-панели".
